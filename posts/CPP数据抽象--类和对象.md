# 类

1. 数据成员

   1. 在创建对象前，类中说明的数据成员并不占有空间，因此在类定义中描述数据成员的时候不给初值，初始化在构造函数那里，但是统一初始化允许用{}规定默认值。
   2. 其中的成员变量声明的时候的类如果没有被声明过或者声明了但是未定义完，那么会因为内存空间未知而无法通过编译，解决这种问题就要通过定义指针啦，不要定义类了

2. 成员函数

   1. 类的定义放在.h文件中，类外定义的成员函数在.cpp文件中
   2. 类的成员函数是可以重载的

3. 成员的访问控制

   1. protected只有派生类 自己 友元可以访问

   2. ```c++
      struct B{
          protected:
          	virtual void f(){}
      }
      struct D : B{
          public:
          	void f(){}
      }
      //这个过程会放宽成public的
      int main(){
          D d;
          d.f();//可以正常调用 因为D的f函数是public的
          B* pb = &d;
          pb->f();//编译检查的时候是按照B::f()来检查的，但是B的f()函数是protected的，外部是不可以访问的
      }
      ```

   1. 

4. 抽象数据类型ADT--Abstract Data Type

   1. 数据对象D
   2. 数据关系R
   3. 操作集合P

   只关注操作接口，不关注操作实现，是一种抽象

# 对象

1. 对象的创建
   1. 直接方式 A a;
   2. 间接方式 A* a = new A; B* b = new B[100];
2. 对象的操作
3. this指针
   1. 成员函数g中怎么知道是对哪个成员操作呢，每一个成员函数都有一个隐藏的形参this \<class> * const this
   2. 常量成员函数就是通过在this变量上面加const实现的

# 对象初始化和消亡前的处理

1. 构造函数分成普通构造函数、复制构造函数、类型转换构造函数、移动构造函数

2. 构造函数和析构函数

   1. 特点：自动调用 无返回类型 可以重载  也有this指针
   2. 子类构造函数执行之前**一定**会优先执行基类的构造函数
   3. 如果封闭类用的默认复制构造函数，或者重写的复制构造函数有成员初始化列表，封闭类的复制构造函数执行之前，一定优先执行对应成员对象的构造函数，如果没有成员初始化列表的话，调用的就是成员对象的默认构造函数了，这个是一定会加上的

   1. 默认构造函数：没有参数的构造函数

      ```c++
      class Student{
          public :
          int sid;
      }
      ```

      1. 不写任何的构造函数，编译器会给你提供默认构造函数形式如下Student(){} 不对成员变量做任何的初始化
      2. 注意一旦写了任何的自定义（不管有没有参数）的构造函数，编译器都不会再提供默认构造函数了
         1. 理由就是C++信任程序员，一旦你写了，会弄不懂你需不需要，那这样我就不提供了
      3. 自己写的时候可以用成员初始化列表的方式 比较快

   2. 成员初始化列表

      ```c++
      class Student{
          public :
          int sid;
          string sname;
          Student(int id,string s):sid(id),sname(s){}
      }
      ```

      	1. 这个的执行先于构造函数体的执行 
      	1. 按照类中的数据成员的声明的次序写 上面这个例子就不能反过来写
      	1. 成员初始化列表可以减轻编译器的负担
      	4. 在构造函数中尽量使用成员初始化表取代赋值动作 
      	 1. 考虑到const和引用类型这种必须先进行初始化的话你是必须用成员初始化列表，因为你赋值操作是错的
      	 2. 效率很高
      	 3. 但是当数据成员过多的时候，不采取该原则，提高可维护性，改的更多

      对于封闭类

      ```c++
      class A
      {      int m;
           public:
             A() { m = 0; }
            A(int m1) { m = m1; }
      };
      
      class B
      {        int x;
                A a;
            public:
                B(){ x = 0; }
               B(int x1) { x = x1; }
              B(int x1, int m1): a(m1) { x = x1; }
      };
      
      void main()
      {      B b1;     
             B b2(1);  
            B b3(1,2); 
            …
      }
      ```

      第一句话调用了B()和A()

      第二句话调用了B(int)和A()

      第三句话调用了B(int,int)和A(int)	

      **对于这种封闭类，先调用成员对象的构造函数在调用自己的，复制的时候也是先执行成员对象的函数体（这些都是在默认的情况下，因为默认的复制会把成员对象写在成员初始化列表里面）如果在执行自己手写的也没这说法，你咋写的就砸执行**	

   3. 就地成员初值 统一初始化 // 写函数的方法不是构造方法

      就地初始化是在哪里初始化都可以的，就是正常的变量，也可以通过{}来进行初始化的，而类里面的变量进行就地初始化叫做统一初始化，就多了这些定义的内容。

   ```c++
   class student{
       int x{0};
       vector<int> v{1,2};
       S s{1，"abc"}//类中的类 成员对象
   }
   ```

   注意这样进行初始化会进行窄化检查

   ```c++
   double d = 3.14;
   class student{
       int a;
       //student(double d) : a(d){} 允许的
       //student(double d) {a = d;} 允许的
       //int a{d}; 这个是不允许的
   }
   ```

   

   4. 委托构造函数 // 写函数的方法不是构造方法

      ```c++
      class A
      {      int m;
           public:
             A() :A(0){}
            A(int m1) { m = m1; }
      };
      ```

        A() :A(0){} 这句话的意思就是把A（）这个函数的执行交给了A（0）执行，执行之后再执行A（）自己的函数体，这个对于父类子类继承那里比较有用

   5. 复制 拷贝 构造函数

      ```c++
      class A
      {      int m;
           
       	//会提供默认的 浅拷贝 只拷贝指针的值不拷贝对象不重新分配空间	
       A(const A& a):m(a.m){}
      };
      ```

      1. 对象之间赋值的时候 默认的赋值函数 A& operator=(const A&){}
      2. 作为函数的参数传入的时候，注意不是引用类型，引用类型不用复制
      3. 作为函数的返回值，临时对象的构造用的是复制构造函数
      4. 编译器提供的复制构造函数是浅拷贝（**如果不写复制构造函数，使用默认的，那么在一个函数中调用这个参数，会导致析构两次发生错误，解决办法就是调用这个对象的引用**），需要自己来写分配空间冲i性能生成一个完成深拷贝

   6. 移动构造函数

      1. 右值引用 int&& A 非常量可以赋值给左值  常量可以赋值给左值或者右值

         Student& s = student(); //no

         Student&& s = student();//yes

      2. **显式使用`std::move`转换左值为右值** 然后调用的就是移动构造函数了

      3. 用临时对象赋值初始化新对象的时候

   7. 什么时候用复制 拷贝 构造函数，什么时候用移动构造函数？

      1. 返回值是左值的时候用复制拷贝函数 返回值是右值的时候用移动构造函数

      2. 返回是左值还是右值怎么看？

         1. 看返回值的类型

         2. 如果返回值的类型是class那一定是右值

         3. 如果返回值的类型是class& 那一定是左值

         4. 如果是函数返回值的话，一般class& 不会出现临时变量，因为返回不去，但是编译能够通过，所以如果程序正常的话不会用临时变量作为左值的情况，所以只有返回值是右值的时候才会用临时对象，因此临时对象也可当作是右值

         5. 注意一点，优化之前，返回值是类的时候会移动构造两次的
            class func(){return class();} 从这个栈拷贝到main函数的栈需要一次移动构造

            class A = func(); 临时对象给对象A赋值的时候需要一次移动构造

            优化之后上面那次的移动构造就不存在了，直接就在main函数里面的栈中构造了

      3. 注意new出来的对象在堆里面效率很低，低于栈和全局

   8. 析构函数也会默认提供~className(){} 默认的析构函数什么都不做的

   9. 类型转换构造函数 和正常的构造函数有两点要求 只有一个参数 不是复制构造函数

      Student(int s) : sid(s){}  Student s1 = 10; s1 = 4;

   10. 什么时候进行析构和构造函数的调用 调用时机

       1. Student s ; // 默认构造函数
   
       2. Student s = s();// 默认构造函数
   
       3. Student s = s(1);//调用s(int i)
   
       4. Student s1; Student s2 = s1;//默认构造 + 复制构造
   
       5. Student* s1= new Student();//默认构造
   
       6. Student* s1 = new Student;//本质上和5是一样的
   
       7. Student s1; calculate(s1);   void calculate(Student s1){}//复制构造函数
   
       8. Student s1; Student s2 = calculate() Student calculate(){Student s3 ; return s3;} // s1默认 s2 复制构造 s3默认构造

       9. Student s1; Student s2 = calculate() Student calculate(){return Student();}//s1默认 s2移动构造

       10. delete的析构函数调用的是如果是非虚析构函数那么就是调用原本类型，反之调用实际类型的 B* p = new C(); B* p = new B(); 如果B的析构函数是虚析构函数，那么前者是C的后者是B的。
   
       11. Parent p = new Child();调用的是new之后的类的构造函数，然后对于一个子类构造之前先调用父类的构造函数然后才是他自己的成员变量如果由成员对象的话才会调用成员对象的成员函数，对象的身份已经发生变化了，属于派生类的特性已经不存在了

       12. Parent& p = c; 和 Parent* p = &c;这两个都是对的

       13. Child& c = p;和Child* c = &p;这两个都是错误的

       14. {}是一个对象的scope 结束就析构，先构造的后析构

       15. new出来的对象只有delete才会析构，否则不会析构

       16. 静态类型的变量在当前函数结束不会消亡，程序结束的时候才会消亡，就是main函数结束的时候和大家一起去死

       17. 临时变量在一个完整的表达式之后就直接析构了，但是如果有const指针 右值引用那么就会等到引用生命周期结束再析构

       18. ```c++
           class B{...};
           class D:public B{...};
           B* p = new D;
           delete p;//如果B是virtual的话，那调用的D的析构函数否则是B的
           ```
   
       19. ```c++
           class MyString{...}
           class B{...}
           class D : public B{
               MyString* name = new MyString;...
           }
           B* p = new D;
           virtual ~B()= default;
           delete p;//如果B的析构函数不是虚函数，那么调用B的析构函数，那么name就没有被析构空间就会一致占用
           ```
   
       20. 
   
   11. 成员变量初始化的方式
   
       1. 就地初始化
       2. 成员初始化列表
       3. 构造函数的函数体
   
   12. 什么时候构造函数和析构函数可以是private的  单例模式 这个类只有一个实例，不允许他的子类派生类更不允许其他类创建 解决办法就是用友元或者直接把方法设为static的，类内可以调用
   
   13. 一个类什么都不写编译器会给你六个默认函数
   
       empty(){}
   
       ~empty(){}
   
       empty(const empty& e);
   
       empty& operator=(const empty& e);
   
       empty* operator&();
   
       const empty* operator&() const;
   
   14. 请简述右值引用和左值引用的异同点
   
       1. 相同点
          1. 本质都是引用，定义的时候必须进行初始化
          2. 都可以用作函数的参数和返回值
       2. 不同点
          1. 左值引用初始化只能是左值，右值引用初始化只能是右值。例如，临时对象只能赋值给右值引用不能给左值引用，对象实例只能给左值引用不能给右值引用
             1. 右值引用和常量引用的差异就在于，常量引用不能当左值用了，因为他的值不能再改了，但是右值引用的本质就变成左值了，可以当左值用，因为常量对象不能调用非常量函数，那如果函数是常量的，那就允许了
          2. 左值引用不会改变原来变量的生命周期，但是右值引用会改变原来变量的生命周期，临时对象
          3. 注意右值引用这个变量本质是左值
   
       
   
       

常量对象的访问--常量成员函数

const

1. 常量
   1. const int i; const double d; const float f;
   2. const int* ptr1; //*ptr1不能改
   3. int* const ptr2;//ptr2不能改
   4. const int& p = (可以用const int或者int都可，而且必须初始化) 但是int& 不能用const int&赋值 // 不可以通过p改，但是原来的那个变量如果是int，通过原来的名称是可以修改的
2. 常量对象
   1. 当定义某个对象的时候，不希望这个对象的值发生改变，可以把这个对象定义称为常量的
   2. class student {}    const student s = s();
   3. 常量对象不允许调用非常量函数，const class& A = func(); A.f()是不允许的 void f(); 但是如果函数写成void f() const;const class& A = func(); 是允许的 
   4. 另外class&& A = func();A.f()是允许的。
3. 常量成员函数 
   1. 在执行期间不能修改其所在的对象的函数，但是静态的除外,静态的常量成员函数根本不存在
   2. 常量对象是在隐含的this上面加const 保证这个函数不会发生改变 class* const this
   3. 如果成员函数是const按道理来讲是不许修改对象的成员变量的，但是如果成员变量是引用eg int& example; example++；这条语句本质上并没有改变example这个引用变量的数值，所以这个是可以编译通过的（优雅的绕过const修改你想改的东西）
   4. mutable：常量成员函数可以修改的变量，在变量定义的前面加上一个mutable，在常量成员函数里面就可以修改了，常量成员函数就是可以修改mutable和static两种类型的

同类对象之间的数据共享--静态成员变量

static 代表静态的

1. 一个类一般会有很多的实例 或者叫做对象，但是当一个成员加上了static修饰的话，那么说明这个类只有一个该变量或者该函数，而且这个不受到对象的影响和这个类仅仅绑定在一起的，因此这个变量或者函数是可以通过类来直接访问的，这时候类也可以被视为一个对象
   static class

2. 注意static的成员函数里面是没有this这个东西的

3. 静态变量的初始化

   class myClass{

    static int a;

   }

   int myClass::a= 0;//正确初始化

4. 静态成员函数不能访问非静态成员变量

5. 非静态成员函数可以访问静态成员变量

6. 常量成员函数不能修改非静态成员变量

   常量成员函数允许修改静态成员变量

提高对象私有数据成员的访问效率--友元（要不然要写set get函数）

友元函数

1. class Vector； 

   class Matrix {    

   ...... 		     

   friend void multiply(Matrix m, Vector v, Vector r);

    };

    class Vector {    

   ...... 	            

   friend void multiply(Matrix m, Vector v, Vector r);

   };

2. 按值传递时，编译器需要知道 `Vector` 类型的**大小**（以便分配栈空间）和**拷贝构造函数**（以便创建参数副本）。

   但此时 `Vector` 是**不完全类型**（仅前向声明，未定义），编译器无法获取其大小和内部结构，因此无法为 `Vector v` 和 `Vector r` 分配内存或生成正确的拷贝代码，导致编译报错。

3. class Vector； 

   class Matrix {    

   ...... 		     

   friend void multiply(Matrix& m, Vector& v, Vector& r);

    };

    class Vector {    

   ...... 	            

   friend void multiply(Matrix& m, Vector& v, Vector& r);

   };这样就是正确的了 引用和指针的空间是可以计算的

4. 友元不具有传递性

5. ```c++
   class Base{
       protected :
       int prot_mem;//只有子类能访问
   };
   class Sneaky : public Base{
       friend void clobber(Sneaky&);
   //可以访问j和Sneaky的prot_mem但是不能访问Base的
       friend void clobber(Base&);
   //可以访问j和Sneaky的prot_mem但是不能访问Base的
       int j;//j默认是private的
   }
   void clobber(Sneaky& s){
       s.j = s.prot_mem = 0;
   }
   void clobber(Base& b){
       b.prot_mem = 0;
       //不可以访问基类的prot_mem，即使他是派生类的友元函数
   }
   ```

6. 派生类的友元函数只能访问派生类从基类继承的protected变量，不能访问基类的protected变量

**new & delete相比malloc 和free的好处在于他们会自动调用构造和析构函数但是后者不会**

# 函数作用域专题

1. 定义在全局的变量，或者static的变量或者main函数的局部变量在main函数结束生命周期才结束
2. 定义在某个函数内部的变量在这个函数结束的时候会结束生命周期
3. 如果浅拷贝，把一个对象传进一个函数（按值传的），那么这个函数结束的时候，会把这个对象析构的，原来的函数结束的时候又会析构一次很危险，所以不要让两个变量指向同一个空间，很危险，但是引用没关系，如果传入的是引用，只不过结束的时候这个别名不会存在了，原来的内容还在
4. 同时在函数的栈上面申请的空间就是局部变量不能做返回值，否则在函数返回的时候会出现错误

