# 前后端代码实现探究

## 前端

1. 前端通过一个函数

   ```vue
   const handleLogin = async () => {
     try {
       const response = await fetch('/api/login', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json'
         },
         body: JSON.stringify({
           username: username.value,
           password: password.value
         })
       })
   
       if (response.ok) {
           message.value = await response.text()
           isError.value = false
           // Redirect to home or dashboard if needed
           // router.push('/dashboard')
       } else {
           message.value = await response.text()
           isError.value = true
       }
     } catch (error) {
       message.value = 'Network error'
       isError.value = true
     }
   }
   ```

   const response = await fetch('/api/login', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json'
         },
         body: JSON.stringify({
           username: username.value,
           password: password.value  
         })
       })通过这里来实现前端对后端的请求的发送

   前端的逻辑会定义这两个变量username.value和password.value

   同时还定义了请求方法是post 请求头 请求body

   `fetch`（原生）小型项目、无需额外依赖原生 API，无需引入第三方库

   Axios（第三方库）中大型项目（Vue/React）、企业级应用功能全、易封装、拦截器强大

   XMLHttpRequest兼容极低版本浏览器（几乎不用）原生底层，兼容性最好

   jQuery.ajax老旧 jQuery 项目适配 jQuery 生态

   SSE 流式响应（如 AI 问答、实时日志）

## 后端--SpringBoot框架

后端分成三层

1. controller层 负责接受前端json（前后端主要的交流信息的格式就是JSON）转化之后的request 调用service层的服务的函数，实现反馈，返回给前端的responseEntity

   1. ResponseEntity 是 Spring Framework 提供的一个非常强大的类，专门用来表示一个 完整的 HTTP 响应 。	

   2. 你可以把它想象成一个**“万能包裹”**，你可以往里面塞进这三样东西：

      1. 状态码 (Status Code) : 比如 200 (OK), 404 (Not Found), 500 (Server Error)。
      2. 响应头 (Headers) : 比如 Content-Type: application/json ，或者自定义的 Token。
      3. 响应体 (Body) : 真正要给前端的数据，比如用户对象、错误提示字符串等。

   3. 响应头 (Response Headers) 就像是包裹在快递盒外面的 物流单 。

      快递盒里面装的是具体的货物（响应体，Response Body），比如你买的衣服（JSON 数据）。而贴在盒子外面的物流单（响应头），则是给 浏览器 或者 快递员 看的附加信息。

      1. Content-Type (最重要的)
         
         - 作用 : 告诉浏览器“盒子里装的是什么”。
         - 例子 : Content-Type: application/json
         - 含义 : “亲爱的浏览器，盒子里装的是 JSON 数据，请按 JSON 格式解析它，不要把它当成图片或 HTML 网页打开。”
      2. Content-Length
         
         - 作用 : 告诉浏览器“盒子有多重”。
         - 例子 : Content-Length: 128
         - 含义 : “数据的大小是 128 字节，收够这么多就算齐了。”
      3. Set-Cookie
         
         - 作用 : 给浏览器下达指令，“把这张小纸条存起来”。
         - 例子 : Set-Cookie: session_id=abc12345
         - 含义 : “下次你再来找我（后端）的时候，记得把这张写着 session_id=abc12345 的小纸条（Cookie）带上，这样我就认识你了。”（这就是登录状态保持的原理）
      4. Cache-Control
         
         - 作用 : 告诉浏览器“这东西能保鲜多久”。
         - 例子 : Cache-Control: max-age=3600
         - 含义 : “这份数据一个小时内都不会变，下次你需要的时候直接从你自己的缓存里拿，别再来烦我了。”
      5. Date
         
         - 作用 : 发货时间。
         - 例子 : Date: Tue, 20 Jan 2026 14:00:00 GMT

   4. // 返回 200 等价的两种写法

      return ResponseEntity.status(200).body("成功");

      return ResponseEntity.ok("成功");

      // 返回 400 等价的两种写法

      return ResponseEntity.status(400).body("参数错误");

      return ResponseEntity.badRequest().body("参数错误");

2. service层 负责实现处理逻辑 就比如注册就是把前端传过来的数据变成entity中的对象

3. repository层 负责将实体类变成sql语言控制Database

dto文件夹下面定义请求类，会在controller中使用，将前端传过来的json数据变成xxxrequest类供controller层使用

**entity文件夹下面一般定义一些类对应一个数据库中的表，这个转化过程是SpringBoot框架JPA提供的**

在 Spring Data JPA（基于 Hibernate）中：

1. 一个类 (Class) = 一张表 (Table)
   
   - 类名通常对应表名（可以自定义）。
   - 例如： class User 对应 users 表。
   - 关键标记 : 类头上必须写 @Entity 注解，这就像是给这个类贴了个标签，告诉系统：“我是数据库表的映射”。
2. 一个对象 (Object) = 一行记录 (Row)
   
   - 当你 new User() 并设置好属性后，这个对象就代表了表里潜在的一行数据。
3. 一个属性 (Field) = 一列 (Column)
   
   - 类里的成员变量（如 private String username ）对应表里的一列。
   - 关键标记 : 主键字段必须加 @Id 注解。

数据库会有很多 在application.propoties里面会定义哪个数据库