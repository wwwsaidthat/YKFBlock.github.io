# 软件测试期末复习

## 第一章 软件测试基础

1. **软件测试基本概念**
   1. 测试用例 简称为测试 一个测试用例tc是一个三元组<t,o,$\theta$>
      1. t 是测试数据或者测试输入，如文字输入数据，交互输入数据等等
      2. o是测试语言或者测试预期输出，用于判断输出结果是否正确的参考依据 这个是预期输出结果
      3. $\theta$ 是测试环境，通常是指运行环境和状态要求
      4. 测试集记作T = {tc~1~,tc~2~,tc~3~,tc~4~... tc~n~},也成为测试套件
   2. 测试报告 通常以文本和图像的形式仅从存储和管理，简单的可以使用Excel表格，测试报告至少要包含如下四个部分<$\theta$,t,o,d>
      1. $\theta$ 是测试环境，通常是硬件和软件配置
      2. t 是测试输入，通常是输入数据和操作步骤
      3. o 是测试输出，通常是输出截图或视频 这个是实际运行结果
      4. d 是结果描述，通常是用于理解错误的信息
2. **软件测试分类**
   1. 根据源代码信息依赖程度分   
      1. 黑盒测试 
      2. 白盒测试  
      3. 灰盒测试 源代码信息不像白盒那样详尽 比黑盒更注重程序的内部逻辑
   2. 根据软件开发流程分 V模型的四个阶段
      1. 单元测试 软件中最小可测试单元
      2. 集成测试 确认在 不同单元模块之间的交互中没有出现问题。
      3. 系统测试  结果是决定软件能否**发布**的重要依据
      4. 验收测试 最终目的是确认系统是否可以**交付**
   3. 根据软件质量属性分 
      1. 功能测试  
      2. 性能测试  发现性能瓶颈
      3. 安全测试
      4. 兼容性测试  验证在不同场景下的运行情况
      5. 易用性测试 
3. **测试分析框架 -- Gourlay 测试分析扩展框架**
   1. 软件测试分析框架可被定义为多元组<**P**,**S**,T,**O**,O>的活动总称
      1. **P**是一组程序 真正程序中实现的功能
      2. **S**是一组规格 文档中规定实现的功能
      3. T是一组测试 用于验证P中实现的是否符合S中的预期
      4. **O** $\subseteq$ **P**$\times$**S**
      5. O $\subseteq$ **P** $\times$ **S** $\times$ T
   2. **O**(P,S)理论上的通用测试预言，表示程序P相对于规范S是正确的 这个是理论上的实际实现不了
   3. O(P,S,t)实际应用中的弱化测试预言，表示在测试t条件下程序徐P相对于规范S被判断为正确 这个是从实际角度来说的
   4. $\forall$ t $\in$ T : O(P,S,t):表示程序P在所有测试都符合规范S
   5. $\neg$ **O**(P,S)：表示程序P不满足规范S，存在缺陷； $\neg$O(P,S,t)类似

# BUG理论

0. 第一个发现BUG的人是格蕾丝·霍伯 1947年9月9日

PIE模型

1. **Fault(Defect) vs Error vs Failure** 

   1. Fault-故障：是指静态存在于程序中的缺陷代码； 
   2. Error-错误：是指程序运行缺陷代码后导致错误的程序状态； 
   3. Failure-失效：是指程序错误状态传播到外部被感知的现象。

   ```java
   public static void CSta(int[] numbers){
       int length = numbers.length;
       double mean,sum;
       
       sum = 0.0;
       for(int i = 1; i < length ; i++){//i = 0; 看出来这里应该从0开始叫做Fault
           sum+=numbers[i];
       }
       mean = sum / (double) length;
       System.out.println("mean:"+mean);
   }
   //运行的时候test input [3,4,5] sum = 4 + 5; 这个叫做error
   //sum = 4 + 5 mean = 3 这个叫做failure
   ```

   

2. 用于解释软件Bug的触发和传播机理 :一个有效的测试t，即在执行测试后程序P外部观测到失效行为，当且仅当需要满足下面三个条件：

   1. Execution：测试必须运行到包含缺陷的程序代码

   2. Infection：程序必须被感染出一个错误的中间状态

   3. Propogation：错误的中间状态必须传播到外部被观察到

      **递进关系**

3. **Bug的存在并不一定导致失效** 

4. **PIE模型不适用于解释深度学习等智能软件系统的缺陷**

5. BUG的正向定义：给定一个完全正确的程序P和测试t，若对于P的修改版本P'若P'(t)失效，则称修改部分P'/P为故障

6. **BUG的反向定义：**给定一个程序P和测试t，若P(t)失效，修改后得到新程序P'若P'(t)通过，那么修改部分P'/P为故障

7. **BUG的不确定性，**如果一个程序P和测试t，若P(t)失效，修改后得到新程序P~1~ P~2~,如果P~1~ $\ne$ P~2~,均使得测试通过，从而确认了P\P~1~ P\P~2~ 为两个不同的故障 （BUG的反向定义导致的）

8. **BUG的非单调性**

   1. 正向 可以通过测试t的P 有两个修改P1<P2 P1通过 P2不通过
   2. 反向 不可通过测试t的P 有两个修改P1<P2 P1通过 P2不通过

9. **BUG间的干涉性**

   1. P有两个故障f1 f2 P1只包含f1 P2只包含f2
   2. P1 P2对于f的表现和P不同就叫做BUG间的干涉性，比如P1 P2都没通过但是P通过了 或者反过来就算
   3. 相长干涉 相消干涉 混合干涉

# 多样性测试

1. 基本原则  从不同视角进行多样性分析 

2. 等价关系

   1. 自反性
   2. 传递性
   3. 对称性

3. 弱一般等价类测试：覆盖每一个变量的有效等价类

4. 弱健壮等价类测试：弱一般等价类测试加上无效等价类

5. 强一般等价类测试：覆盖每一个变量每个有效等价类

6. 强健壮等价类测试：覆盖每一个变量每个等价类（强一般+无效）

7. 软件失效的故障模式 点模式 带模式 块模式

8. FSCS-ART fixed size candidate set adaptive random test

9. 随机测试

   1. 简单随机测试 随便抽 针对输入空间 ，随机测试以概率分布 进行随机抽样获得测试集
   2. 自适应随机测试ART 测一个 抽一个和这个最不一样的 采用距离引导自适应随机测试  自适应随机测试以概率分布进行**随机抽样**并**结合距离度量反馈信息**获得测试集
      1. 随机抽样
      2. 根据距离反馈信息获得接下来的测试集中的内容
      3. 步骤 
         1. 初始化
         2. 执行测试
         3. 反馈控制
         4. 选择测试
         5. 循环重复
   3. 引导性随机测试 有预定的方向的随机测试

10. 等价类测试方法

    1. P-度量 测试集至少包含一个失效测试的概率
    2. E-度量 测试集触发软件失效次数的数学期望
    3. E-度量比P-度量更能反映测试方法的有效性
    4. F-度量 检测到第一个缺陷时所需的测试数量
    5. 等价类划分
       1. 确定划分域：确定程序输入或输出的范围
       2. 划分等价类：将输入域或输出域划分为等价类
       3. 选择代表性测试：从每个等价类中选择代表性测试
    6. 划分随机测试 
       1. 划分
       2. 随机
       3. 划分随机测试对于 𝐾 个子域 𝐷1 , ··· , 𝐷𝑘， 针对相应的概率 𝑃1, ··· , 𝑃𝑘 来 分配每个 子域的强度。即为了构建大小为 𝑁 的测试集，随机为 子域 𝐷𝑖 生成 𝑁𝑖 个测试 𝑁𝑖 = 𝑝𝑖 ∗ 𝑁。

11. 组合测试

    1. 基本概念

       1. 参数 影响软件行为的输入变量或者配置选项

       2. 取值 每个参数都有一个或多个可能的取值

       3. 组合强度 k 代表测试样例需要覆盖kk组合的全部参数组合

          组合强度是k代表测试样例要覆盖所有参数的kk组合

      		2. 组合生成：
           		1. 候选生成
           		2. 覆盖评分
           		3. 选择最有候选
           		4. 更新未覆盖集合
      		3. ACTS工具支持组合测试 ACTS专注于组合用例生成 Automated Combinational Testing for Software 
           		1. 核心算法IPO 先生成2-way然后再增加强度到3-way...
           		2. PICT也是组合测试的一种工具
      		4. 约束组合测试 优先确定组合的各个参数之间的约束关系
      		5. 种子组合测试要求最终的测试集包含给定的测试，进而再满足k-因素的组合要求 针对性强
      		6. 可变力度组合 核心参数3-way 次要参数2-way

# 故障假设测试

1. 变异分析的假设
   1. 等价变异假设 精心设计的变异体可以模拟缺陷
2. 熟练程序员假设
   1. 程序员写出的代码知识存在微小的问题不是大的啥也不是的屎山
3. 耦合效应假设
   1. 可以单独检测出每个问题那么也可以检测出他们相互组合产生的问题
4. 弱变异测试vs强变异测试
   1. 弱：执行 + 感染
   2. 强：执行 + 感染 + 传播
5. OFFUTT五个基本算子
   1. AOR（算数操作符） 
   2. ABS 
   3. LCR(逻辑连接符) 
   4. ROR（关系运算符） 
   5. UOI（一元操作符插入）
6. 边界故障假设
   1. 黑盒故障假设 不知道程序具体的实现细节 只能通过 “输入数据→观察输出结果” 来判断系统是否有缺陷。--输入域边界
   2. 白盒故障假设白盒边界故障假设主要关注代码中的判定决策点，如 条件语句、循环语句，也包括更加细致的逻辑操作符。 通常包括输入范围的最小值、最大值，以及刚好超出 范围的值。这里的值往往是逻辑的真假值。--逻辑边界

2. 变异缺陷假设
   	1. 变异分析的奠基假设：
       	1. 熟练程序员假设：熟练程序员编写有缺陷的代码和正确的代码非常接近
       	2. 耦合效应假设 ：如果测试能够检测单一缺陷，也能检测耦合的复杂缺陷
   	2. 基本概念：
       	1. 变异体：变异体P’是原程序P经过符合语法规则的微小代码修改的程序版本
       	2. 变异体检测：若能存在t使得P(t)$\ne$P'(t)，则称实验t杀死P'
       	3. 变异分数：$\frac{杀死的P'个数}{变异体总个数}$
       	4. 等价变异体：如果不存在t$\in$T能够杀死P'则对于T来说P‘就是P的等价变异体
       	5. 变异算子：符合程序语法规则的前提下，变异算子定义了生成变异体的变异规则

 	3. 变异测试优化技术：
     	1. 变异体选择优化
         	1. 变异算子选择：从经验上相似的变异算子中选择代表性的变异算子。 
         	2. 变异体随机选择：从经验上相似的变异体进行均匀随机抽样得到样本。 
         	3. 变异体聚类抽样：对变异体进行聚类分析然后进行随机抽样得到样本。逻辑故障假设
     	2. 变异体执行优化

3. 软件逻辑故障是指在程序代码中存在的逻辑错误或不当的设计，导致程序无法按照预期执行或出现异常行为。
   1. 操作符引用故障（ORF） 
   2. 表达式否定故障（ENF）
   3. 变量否定故障(VNF) 
   4. 关联转移故障（ASF）
   5. 变量丢失故障（MVF） 
   6. 变量引用故障（VRF） 
   7. 子句合取故障（CCF） 
   8. 子句析取故障（CDF） 
   9. 0固化故障（SA0） 
   10. 1固化故障（SA1）
4. 浮点计算稳定性 前向误差 后向误差 混合稳定性三种类型
   1. 前向是指输出和精确的差值
   2. 后向是指为了让输出是能精确计算的，需要对输入改多少
   3. 混合就是两个一起

# 图分析测试

1. 图基础概念 

   1. 顶点集合
   2. 初始顶点
   3. 终结顶点
   4. 边集合

2. 控制流图 

   1. 划分基本块
      1. 第一句 
      2. 跳转语句下一句
      3. 被跳转到的地方的下一句
   2. 基本块的出口
      1. 下一个入口的前导语句
      2. 转移语句
      3. 停语句

3. 数据流图 

4. 事件流图  

5. 图结构测试方法 

   1. L-路径覆盖准则 通过定义不同长度的路径覆盖准则，来检验图中所有或者部分路径是否被测试用例覆盖 
      1. L = 0 把所有长度为0的路径覆盖 -- 顶点覆盖 语句覆盖
      2. L = 1 把所有长度为1的路径覆盖 -- 边覆盖 分支覆盖
      3. L = 2 把所有长度为2的路径覆盖
      4. 先找到所有长度为L的路径，然后找用例来覆盖
   2. 主路径测试 
      1. 简单路径是指没有重复顶点或者本身就是环路的路径不包含内部回路
      2. 主路径是指延申简单路径直到再延申的画不是简单路径，所有包含主路径的路径都不是主路径
      3. 测试集必须包含所有的主路径
   3. 基路径测试 
      1. 要求覆盖所有路径的最少路径数目
      2. 线性空间基向量数量等于空间维数，对于e个边的图，基向量的个数不会超过e
      3. 基本路径数量等于程序的圈复杂度CC(G)=e-n+2 其中e为边的数目，n为节点数目 
      4. 独立路径数 = 圈复杂度

6. 图元素测试 

   1. 数据流测试 

      看程序数据怎么流，数据的生命周期的正确性 def-use检测 关注def和use的覆盖情况 ADC<AUC<ADUAC

   2. 逻辑测试（谓词覆盖（分支覆盖））

      看程序怎么走，关注顺序的正确性 关注逻辑表达式的覆盖情况 准则要求程序中每个条件判定语句的真假值结果至少出现一次

      判断覆盖（谓词覆盖）和条件覆盖（子句覆盖）

       每个谓词至少取一次真和假

      eg if (score >= 60) && (attendance >= 0.8): 

      判断覆盖是需要判断 (score >= 60) && (attendance >= 0.8)为真为假的情况共两种情况

      条件覆盖是(score >= 60)为真为假和 (attendance >= 0.8)为真为假的情况共四种情况

      **X满足Y不满足 X强度高于Y 所以谓词覆盖强度高**

# 开发者测试

1. 单元测试 

   单元测试的3A 原则是一种指导单元测试编写的规范，它将测试过程分为三个清晰的步骤：**Arrange (准备)、 Act (执行)、Assert (断言)。**

2. 接口测试 

   接口测试是指针对软件系统中的接口进行的测试，以验证接口是否能够按照预期进行通信和数据交换。 

   接口测试在单元测试之后 UI测试之前

3. 集成测试 

   集成测试旨在验证软件组件的协同工作能力，并检测系统功能性和性能问题。 

4. 多样性开发者测试 

   1. 多样性测试又称为变异测试，是一种用于评估测试质量的方法，它通过修改源代码生成变异体，然后运行测试集，观察测试集能否检查到变异体中的缺陷

5. 故障假设开发者测试 变异测试 

6. 基本概念、测试粒度、测试优势的基本理解

   1. 测试粒度
      1. 代码 单元 集成 功能 系统
   2. 

# 功能测试

1. 什么是功能测试？ 

   功能测试是一种验证软件或应用程序是否按预期工作的方法，关注结果是否正确而非内部处理过程。通过 为每个功能提供适当的输入，并验证输出是否符合预定义要求，确保系统功能特性满足最终用户的需求。为了评估测试的完整性，功能测试使用功能需求点覆盖率，通过分析已执行的测试来确保所有需求被覆盖。

   确定功能需求-设计测试用例-执行测试与验证

2. 多样性功能测试

   1. 等价类划分 ：等价类划分是软件测试中基于功能点将输入域划分为有效与无效两个子集的方法，同一子集的输入数据对 程序功能实现等效。 
      1. 有效等价类：符合规格说明的合理输入，用于验证功能正确性。 
      2. 无效等价类：不符合规格说明的异常输入，用于测试程序的容错能力。
   2. 什么是因果图？ 因果图是一种系统化的测试设计技术，通过分析程序输入（原因）与输出（效果）之间的逻辑关系，帮助 选择高效的测试集。
   3. 类别划分（Category-Partition, CP）概述 类别划分测试方法是一种系统化的功能测试技术，通过识别参数和环境变量，将其划分为类别，并为每个 类别生成选项，最终组合成测试框架。

3. 故障假设功能测试

   1. 测试规划与分析 
   2. 测试实施方法 
   3. 测试评估与改进

   

   

   

# 性能测试

1. 基本概念：性能测试是一种评估软件或系统在实际运行环境中表现的方法，通过模拟真实用户行为，评估系统在响应 时间、吞吐量和资源利用率等指标的表现，确保其满足预定的性能需求。利用负载模拟和压力测试，分析系统 在不同负载下的表现，发现并解决性能瓶颈，优化资源使用效率，保障系统高效运行。

2. 常见的性能测试类型 

   1. 并发测试：模拟多用户同时操作，评估系统在高并发下的稳定性和响应能力，旨在发现并发引起的问题。 
   2. 负载测试：在正常负载下逐步施压，评估系统性能极限，帮助了解系统容量并支持性能调优。
   3. 压力测试：模拟超预期负载，测试系统在极端条件下的崩溃点和恢复能力，找出最大承载能力

3. 多样性性能测试

   1. 什么是多样性性能测试？

      多样性性能测试是指通过模拟多种不同的情境和条件，全面评估系统在各种环境下的性能表现的一种测试 方法。它的核心在于多样化的测试场景和条件，以确保系统能够在不同的压力、配置和环境中稳定运行，并满 足性能需求。

   2. 多样性性能测试情境和条件：

      1. 不同的负载：测试系统在不同负载下的表现，如响应时间、吞吐量和并发用户数等性能指标。 
      2. 不同的网络条件：测试系统在网络延迟、带宽限制等不同网络条件下的表现。 
      3. 不同的硬件和软件配置：测试系统在不同硬件和软件环境下的性能。

4. 故障假设功能测试

   1. 故障变异算子，七个性能变异算子

      ![image-20260101174947602](C:\software\Typora\picture\image-20260101174947602.png)

# 适配测试

1. 基本概念：信创适配测试促使国产软件开发商与硬件厂商、操作系统供应商等密切合作。软件开发商为适配新硬件和 系统特性，需与上下游企业共享技术信息、协同解决问题。例如，国产数据库软件在适配国产服务器时，需与 服务器厂商共同优化数据存储和读取性能，与操作系统供应商协作完善数据安全管理机制。
2.  信创适配测试的关注点
   1. 环境适配性上，针对龙芯、飞腾等国产芯片，麒麟、统信等国产操作系统，达梦、人大金仓等国产数据 库及各类国产中间件的多元组合，全面检测信创产品兼容性与稳定性； 
   2. 性能层面，模拟高并发、大数据量等实际场景，开展压力与负载测试，评估产品响应时间、吞吐量等性 能指标； 
   3. 功能实现方面，依据功能需求设计测试用例，保障产品各项功能在不同地区、网络环境及终端设备上正 常运行； 
   4. 接口兼容性上，测试不同信创产品间接口，推动产品协同工作，全方位确保信创产品质量、性能、安全 等符合要求。
3. 信创适配测试的原则
   1. 兼容性原则：确保测试环境中的各类国产硬件设备（如 CPU、服务器、存储设 备等）与国产软件（操作系 统、数据库、中间件等）能够协同工作，实现良好的兼容效果。 
   2. 可扩展性原则：充分预估信创产业发展趋势以及企业未来业务增长规模，在搭建测试环境时预留足够的扩 展空间，灵活适应新的软硬件测试需求。 
   3. 稳定性原则：测试环境需具备高度的稳定性，以保证测试结果的准确性与可靠性。在长时间的测试过程中， 环境中的各类组件应保持稳定运行状态，减少因环境波动导致的测试误差。 
   4. 安全性原则：严格遵循国家信息安全相关标准与规范，构建安全可靠的测试环境。从网络安全防护、数据 加密存储到用户权限管理等各个层面，防止敏感信息泄露，全面保障测试过程中信息的安全性。
4. 多样性适配测试
5. 故障假设适配测试

# 模糊测试

1. 基本概念 

   模糊测试是一种黑盒测试，通过向目标系统或者程序输入大量随机、无效、异常或者半有效的数据，观察系统是否会出现崩溃、卡死报错的现象，从而发现传统测试方法难以覆盖的潜在缺陷

   工具：模糊器（Fuzzer） 

   目标：待测程序（PUT） 

   循环：执行程序 ⇄ 崩溃分派（Crash Triage）

2. 整体流程

   ![image-20260102151125438](C:\software\Typora\picture\image-20260102151125438.png)

3. 设计变异算子 

4. 设计有效反馈

# 测试用例优先级

1. 定义：通过设定特定优先级准则（执行时间，代码覆盖等），对测试 用例进行优先级排序以优化其执行次序，旨在最大化优先级目标，例 如最大化测试用例集的早期缺陷检测速率 
2. 优先级的基本算法
   1. 贪心
   2. 自适应随机
3. 优先级的评估